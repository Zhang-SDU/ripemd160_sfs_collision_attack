#include <iostream>
#include <bitset>
#include <vector>
#include <thread>
#include <atomic>
#include <string>
#include <cstdint>
#include <chrono>
#include <random>
#include <chrono>

using namespace std;

constexpr int s_left[48] = {11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 
    8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 
    13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5};

constexpr int s_right[48] = {8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9,
                13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12,
                13, 5, 14, 13, 13, 7, 5};

constexpr int message_order_left[48] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
                        7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 
                        3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12};

constexpr int message_order_right[48] = {5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
                        6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6,
                        9, 11, 8, 12, 2, 10, 0, 4, 13};

constexpr uint32_t K_left[5] = {0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e};

constexpr uint32_t K_right[5] = {0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000};

vector<string>filterBool_left = {"XOR", "IFX", "ONZ", "IFZ", "ONX"};
vector<string>filterBool_right = {"ONX", "IFZ", "ONZ", "IFX", "XOR"};

uint32_t leftRotate(uint32_t n, int s) {
    n = n & 0xffffffff;
    return ((n << s) | (n >> (32 - s)) & 0xffffffff);
}

uint32_t rightRotate(uint32_t n, int s) {
    n = n & 0xffffffff;
    return ((n >> s) | (n << (32 - s)) & 0xffffffff);
}

uint32_t IFX(uint32_t x, uint32_t y, uint32_t z) {
    return ((x & y) ^ (~x & z));
}

uint32_t ONZ(uint32_t x, uint32_t y, uint32_t z) {
    return (x | ~y) ^ z;
}

uint32_t XOR(uint32_t x, uint32_t y, uint32_t z) {
    return x ^ y ^ z;
}

uint32_t IFZ(uint32_t x, uint32_t y, uint32_t z) {
    return ((x & z) ^ (y & (~z)));
}

uint32_t ONX(uint32_t x, uint32_t y, uint32_t z) {
    return (y | (~z)) ^ x;
}

vector<uint32_t> step_function_full(uint32_t x0, uint32_t x1, uint32_t x2, uint32_t x3, uint32_t x4, uint32_t m, int s, string fNa) {
    uint32_t b0;
    if (fNa == "XOR"){
        b0 = XOR(x4, x3, leftRotate(x2, 10)) & 0xffffffff;
    }
    else if (fNa == "IFX"){
        b0 = IFX(x4, x3, leftRotate(x2, 10)) & 0xffffffff;
    }
    else if (fNa == "ONZ"){
        b0 = ONZ(x4, x3, leftRotate(x2, 10)) & 0xffffffff;
    }
    else if (fNa == "IFZ") {
        b0 = IFZ(x4, x3, leftRotate(x2, 10)) & 0xffffffff;
    }
    else if (fNa == "ONX") {
        b0 = ONX(x4, x3, leftRotate(x2, 10)) & 0xffffffff;
    }
    uint32_t b1 = (b0 + leftRotate(x0, 10) + m) & 0xffffffff;
    return {x1, x2, x3, x4, (leftRotate(x1, 10) + leftRotate(b1, s)) & 0xffffffff};
}


vector<uint32_t> ripemd(vector<uint32_t> initial_IV, vector<uint32_t> state, vector<uint32_t> m, int step){
    vector<uint32_t> left(5,0);
    vector<uint32_t> right(5,0);
    for (int i = 0; i < 5; i++){
        left[i] = state[i];
        right[i] = state[i];
    }
    for (int i = 0; i < step; i++){
        left = step_function_full(left[0], left[1], left[2], left[3], left[4], m[message_order_left[i]] + K_left[i >> 4], s_left[i], filterBool_left[i >> 4]);
        // cout << i << " " << bitset<32>(left[4]) << endl;
        right = step_function_full(right[0], right[1], right[2], right[3], right[4], m[message_order_right[i]] + K_right[i >> 4], s_right[i], filterBool_right[i >> 4]);
    }

    // hash output
    vector<uint32_t> hash(5, 0);
    hash[0] = initial_IV[1] + left[3] + leftRotate(right[2], 10);
    hash[1] = initial_IV[2] + leftRotate(left[2], 10) + leftRotate(right[1], 10);
    hash[2] = initial_IV[3] + leftRotate(left[1], 10) + leftRotate(right[0], 10);
    hash[3] = initial_IV[4] + leftRotate(left[0], 10) + right[4];
    hash[4] = initial_IV[0] + left[4] + right[3];

    return hash;
}


int main() {
                                                                                                                                                                                             
    int step = 41;
    

    // colliding message pair1
    vector<uint32_t> initial_IV = {0b11011111001000001011010101011001,
        0b01000101110100011110110010011111,
        0b10110011110000110000101001100001,
        0b00111100001111000110011011010101,
        0b10001011110011111111010111000111};    

    
    uint32_t m[16] = {0b11000100000010001100111101010011,
        0b00011110000111110101111011001111,
        0b11010101001000111101111010010011,
        0b10001011101001100100000000000011,
        0b11100101101101011000101010000101,
        0b10111001100111010110001001000011,
        0b01010100111001101010111100110100,
        0b11111100001011001010000000110100,
        0b00100111110000001001111100111001,
        0b11101000001100000000110110100110,
        0b10100100111111111111010010010100,
        0b00111110111110110111011111010100,
        0b00000100101011011010111011111001,
        0b10110110000111001010110011010010,
        0b10001010111000011100000011111010,
        0b10111100000000000010101001100101};

    // X_-5 = h0 >>> 10; X_-4 = h4 >>> 10; X_-3 = h3 >>> 10; X_-2 = h2, X_-1 = h1
    vector<uint32_t> state_IV(5,0);
    state_IV[0] = rightRotate(initial_IV[0], 10);
    state_IV[1] = rightRotate(initial_IV[4], 10);
    state_IV[2] = rightRotate(initial_IV[3], 10);
    state_IV[3] = initial_IV[2];
    state_IV[4] = initial_IV[1];
    
    vector<uint32_t> m0(16, 0), m1(16, 0);

    // message pair
    for (int i = 0; i < 16; i++){
        if (i == 12){
            m0[i] = m[i];
            m1[i] = m[i] + pow(2,15);
        }
        else{
            m0[i] = m[i];
            m1[i] = m[i];
        } 
    }

    vector<uint32_t> hash0(5, 0), hash1(5, 0);
    hash0 = ripemd(initial_IV, state_IV, m0, step);
    hash1 = ripemd(initial_IV, state_IV, m1, step);
    
    cout << "CV0:" << endl;
    for (int i = 0; i < 5; i++) {
        cout << hex << initial_IV[i] << endl;
    }

    cout << endl << "m0: " << endl;
    for (int i = 0; i < 16; i++) {  
        cout << hex << m0[i] << endl;
    }

    cout << endl << "m1: " << endl;
    for (int i = 0; i < 16; i++) {  
        cout << hex << m1[i] << endl;
    }

    cout << endl << "hash0:" << endl;
    for (int i = 0; i < 5; i++) {  
        cout << hex << hash0[i] << endl;
    }

    cout << endl << "hash1:" << endl;
    for (int i = 0; i < 5; i++) {  
        cout << hex << hash1[i] << endl;
    }
}


// ################################### 41-step collision attack using the differential characteristic identified by our improved model ###################################
// colliding message pair1
// vector<uint32_t> initial_IV = {0b11100110111000010000000010000000,
//     0b00101110011010000100110010100111,
//     0b11010001001011100011001000101010,
//     0b10010110101101111000110001000100,
//     0b11010010000101000000001010110011};    

// uint32_t m[16] = {0b00100010111111011000010000011110,
//     0b00001001111101101101010110101110,
//     0b11110001111111001000101001010101,
//     0b01110111011010001111111011111001,
//     0b00101111100010000000111100110100,
//     0b10111001001010000010011001111111,
//     0b11110111011110010010001010100011,
//     0b11110100111111001010100000001001,
//     0b11000100101101010111111101101101,
//     0b11111000101110001100100111011111,
//     0b00101111000111010110100101011001,
//     0b10000010010101111011110011000000,
//     0b01000010011111010001000010001100,
//     0b00110111101010010101110001101111,
//     0b10010111000010111000111011010101,
//     0b01001100101000001100110000100010};



// colliding message pair2
// vector<uint32_t> initial_IV = {0b00000000101010000110110011010100,
//     0b11110010000101001111111100101110,
//     0b10101111011111001111000010111010,
//     0b01100110001100100010110011110111,
//     0b01000000011011111010001010001010};    

// uint32_t m[16] = {0b00100010111111011000010000011110,
//     0b00111010111101001111100111001100,
//     0b11110001111111001000101001010101,
//     0b01110111011010001111111011111001,
//     0b00101111100010000000111100110100,
//     0b10111001001010000010011001111111,
//     0b11110111011110010010001010100011,
//     0b00101111110011100000001000100010,
//     0b11000100101101010111111101101101,
//     0b11111000101110001100100111011111,
//     0b00101111000111010110100101011001,
//     0b10000010010101111011110011000000,
//     0b01000010011111010001000010001100,
//     0b10001100010000010101111101110100,
//     0b10010111000010111000111011010101,
//     0b01001100101000001100110000100010};



// colliding message pair3
// vector<uint32_t> initial_IV = {0b11001000111011101001111100001010,
//     0b10010101111010011100110111100011,
//     0b00100100100001010011001101100100,
//     0b00100111001111111001011011101111,
//     0b10101100000010110001010010011101};

// uint32_t m[16] = {0b00100010111111011000010000011110,
//     0b11101011101001011111100101111101,
//     0b11110001111111001000101001010101,
//     0b01110111011010001111111011111001,
//     0b00101111100010000000111100110100,
//     0b10111001001010000010011001111111,
//     0b11110111011110010010001010100011,
//     0b00100010010011000100110011110111,
//     0b11000100101101010111111101101101,
//     0b11111000101110001100100111011111,
//     0b00101111000111010110100101011001,
//     0b10000010010101111011110011000000,
//     0b01000010011111010001000010001100,
//     0b10011011100111000100001110011011,
//     0b10010111000010111000111011010101,
//     0b01001100101000001100110000100010};



// colliding message pair4
// vector<uint32_t> initial_IV = {0b10101100101010011010011101011111,
//     0b01111000001101000111111001110111,
//     0b00101011011100001110011100101100,
//     0b11010011000111001111100000111111,
//     0b10010001000101111100100100011011};    

// uint32_t m[16] = {0b00100010111111011000010000011110,
//     0b00001011110101001101010111101111,
//     0b11110001111111001000101001010101,
//     0b01110111011010001111111011111001,
//     0b00101111100010000000111100110100,
//     0b10111001001010000010011001111111,
//     0b11110111011110010010001010100011,
//     0b01100011100011010100101110111101,
//     0b11000100101101010111111101101101,
//     0b11111000101110001100100111011111,
//     0b00101111000111010110100101011001,
//     0b10000010010101111011110011000000,
//     0b01000010011111010001000010001100,
//     0b00000000101010101110001001110111,
//     0b10010111000010111000111011010101,
//     0b01001100101000001100110000100010};



//  colliding message pair5
// vector<uint32_t> initial_IV = {0b11111011011001001101000001100011,
//     0b10000111111111100000010111001011,
//     0b01001100010001011000111010000111,
//     0b01010011010010011000010101010011,
//     0b00011111100001010000011100101010};    

// uint32_t m[16] = {0b00100010111111011000010000011110,
//     0b00110111111011001100010101010101,
//     0b11110001111111001000101001010101,
//     0b01110111011010001111111011111001,
//     0b00101111100010000000111100110100,
//     0b10111001001010000010011001111111,
//     0b11110111011110010010001010100011,
//     0b01111001011110010101110101111101,
//     0b11000100101101010111111101101101,
//     0b11111000101110001100100111011111,
//     0b00101111000111010110100101011001,
//     0b10000010010101111011110011000000,
//     0b01000010011111010001000010001100,
//     0b10011100010110101010101001010011,
//     0b10010111000010111000111011010101,
//     0b01001100101000001100110000100010};


// ################################### 41-step collision attack using the differential characteristic from FSE 2024 ###################################

// colliding messgae pair1
// vector<uint32_t> initial_IV = {0b00010110101010110110011000101000,
//     0b10000011001100001110100011010000,
//     0b00011001101000111000111001010001,
//     0b10010111111010100101111011001100,
//     0b01100101110111000000011000111100};    

    
// uint32_t m[16] = {0b11000100000010001100111101010011,
//     0b00100111111101110110011010010000,
//     0b11010101001000111101111010010011,
//     0b10001011101001100100000000000011,
//     0b11100101101101011000101010000101,
//     0b10111001100111010110001001000011,
//     0b01010100111001101010111100110100,
//     0b11010001001110000000100100001011,
//     0b00100111110000001001111100111001,
//     0b11101000001100000000110110100110,
//     0b10100100111111111111010010010100,
//     0b00111110111110110111011111010100,
//     0b00000100101011011010111011111001,
//     0b10101011001110001111111111100101,
//     0b10001010111000011100000011111010,
//     0b10111100000000000010101001100101};


// colliding message pair2
// vector<uint32_t> initial_IV = {0b11011111001000001011010101011001,
//     0b01000101110100011110110010011111,
//     0b10110011110000110000101001100001,
//     0b00111100001111000110011011010101,
//     0b10001011110011111111010111000111};    

// uint32_t m[16] = {0b11000100000010001100111101010011,
//     0b00011110000111110101111011001111,
//     0b11010101001000111101111010010011,
//     0b10001011101001100100000000000011,
//     0b11100101101101011000101010000101,
//     0b10111001100111010110001001000011,
//     0b01010100111001101010111100110100,
//     0b11111100001011001010000000110100,
//     0b00100111110000001001111100111001,
//     0b11101000001100000000110110100110,
//     0b10100100111111111111010010010100,
//     0b00111110111110110111011111010100,
//     0b00000100101011011010111011111001,
//     0b10110110000111001010110011010010,
//     0b10001010111000011100000011111010,
//     0b10111100000000000010101001100101};
